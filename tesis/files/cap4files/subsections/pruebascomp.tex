\subsection{Pruebas Individuales de Componentes con Arduino }
\par \noindent
Todas las pruebas fueron realizadas utilizando un Arduino nano; ya que permite un manejo sencillo con un breadboard y será el que utilizaremos en el prototipo final. Se empezó con el sensor de temperatura DS18B20.

\subsubsection{Arduino y DS18B20}
\par 
Si se lee detenidamente el datasheet del DS18B20 uno se percata que es más complejo que un simple termopar para medir la temperatura. Cuenta en su forma de sonda con distintos circuitos integrados que permiten la fácil integración con Arduino. El DS18B20 utiliza tres alambres. Uno para la alimentación de 5V, otro para tierra y uno de información o data. Este último es conectado a través de una resistencia de 4.7K ohmios en paralelo con una alimentación de 5V y cualquier pin digital de Arduino. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{pruebas1.jpg}
	\caption{Conexión Sencilla entre Arduino Nano y Sensor de Temperatura DS18B20}
\end{figure}

\par \noindent
En la figura 3.1 se seleccionó el pin digital 10 para enviar la información y se ve como el sensor fue conectado a la salida de 5V del Arduino y su respectivo GND, adicional se ve una resistencia de 4.7K entre el cable de DATA del sensor y una conexión al pin 10. 

\par \noindent
Ahora utilizando el software platformio, el entorno de desarrollo que se utilizó para programar la placa Arduino, se escribió un código de prueba. Para ellos se necesitaron dos librerías: OneWire \cite{onewire-github} y DallasTemperature \cite{dallas-github}. El código de prueba sería el siguiente: \\

\begin{lstlisting}[language=C++, caption={Código Ejemplo para DS18B20}, captionpos=b]
#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS 10

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

void setup(){
Serial.begin(9600);
sensors.begin();
}


void loop(){
Serial.print("Requesting temperatures...");
sensors.requestTemperatures(); 
Serial.println("DONE");
Serial.print("Temperature:");
Serial.println(sensors.getTempCByIndex(0));
delay(1000);
}
\end{lstlisting}

\par \noindent
El código anterior puede ser encontrado como uno de los ejemplos que trae la librería DallasTemperature[30] bajo el nombre "Simple.pde" y puede ser escrito por cualquier editor de texto. El código básicamente es crear una instancia de la clase OneWire y esa instancia colocarla como argumento dentro del objeto "sensors". En la función setup (se ejecuta una sola vez). Se inicializa el puerto serial a 9600 baudios y se inicializa el objeto "sensors" de clase DallasTemperatures. En la función loop, se ejecuta toda la función, desde el inicio hasta el final, una y otra vez; hasta que se apague el microcontrolador. Se imprime en la terminal de la computadora y se ejecuta la función "requestTemperatures" que llama todos los posibles DS18B20 que se encuentren en el mismo bus. Por último, se imprime en la terminal de la computadora el resultado de la función "getTempCByIndex" donde si está conectado un DS18B20 retorna la temperatura captura en grados Celsius; en caso tal de no encontrarse ningún DS18B20 en el circuito, el valor retornado es "-127" constante de definida en la librería DallasTemperature.

\par \noindent
Una vez se subió el código a nuestro Arduino, se debe validar que el sensor funcione correctamente, pero ¿cómo? Conectado el Arduino a una computadora se utiliza el puerto serial del entorno de desarrollo. Si se utiliza el IDE oficial de Arduino, basta con hacer clic en la barra superior la opción "herramientas" y seleccionar "Monitor Serial". Como se implementó Platformio como IDE, basta con seleccionar en la barra de herramientas "Platformio", la opción "Serial Monitor". Esencialmente lo que hace esa opción es escribir en la terminal de comandos "pio device monitor port COM5" y con eso es posible comunicarnos con la placa Arduino a través de un puerto Serial. En la figura 3.2, se visualiza el resultado del código 3.1, en ejecución por el microcontrolador.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{pruebas2.png}
	\caption{Terminal de Windows visualizando temperatura capturada por sensor DS18B20, a través de comunicación serial.}
\end{figure}

\par \noindent
Se comprobó como capturar mediciones de temperatura en tiempo real. Sin embargo, no es práctico para el usuario final tener que cargar una computadora, conectar el Arduino y abrir una terminal. Aquí es se necesita la pantalla LCD ILI9348.

\subsubsection{Arduino y Pantalla LCD ILI9341}

\par 
Luego de hacer la investigación pertinente encontró una guía para utilizar la pantalla LCD con el Arduino \cite{edu8tv}. En ella se detalla que la pantalla LCD tolera 5V; sin embargo, el controlador ILI9341 no. Por lo tanto la guía recomienda utilizar resistencias de 10K en serie con el Arduino para establecer una comunicación satisfactoria.

\par \noindent
El controlador de la pantalla utiliza el bus SPI del Arduino, SPI por sus siglas en inglés es Serial Pheripheral Interface, el cual es un interfaz de bus comúnmente utilizado para enviar información entre microcontroladores, sensores, tarjetas SD y otros dispositivos. Por lo que las conexiones del LCD están definidas hacia los pines digitales 13, 12 y 11 para poder comunicarse con el Arduino.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{pruebas3.png}
	\caption{Conexión entre Arduino y LCD ILI9341, utilizando resistencias de 10K en serie.}
\end{figure}

\clearpage

\par \noindent
Cabe a destacar que el circuito de la figura 3.3, utiliza dos componentes pasivos adicionales a las resistencias. Estos son dos capacitores, uno electrolítico de 10 uF, ayuda a filtrar frecuencias bajas y otro de cerámica de 1nF el cual ayuda a filtrar altas frecuencias. El conjunto de ambos brinda una fuente de poder estable a el elemento.

\par \noindent
La pantalla cuando es conectada al Arduino solamente despliega la luz de fondo de color blanco. Para programar los pixeles se utilizarón dos librerías: Adafruit\_ILI9341\cite{adafruit-lcd} y Adafruit-GFX-Library\cite{adafruit-gfx} ambos de los mismos desarrolladores de Adafruit; Adafruit es una compañía de hardware de código abierto y es uno de los principales contribuidores del proyecto Arduino. Se utilizó uno de los códigos ejemplos que vienen con las librerías para verificar el funcionamiento del componente como en la figura 3.3

\begin{lstlisting}[language=C++, caption={Código Ejemplo para pantalla LCD ILI9341}, captionpos=b]
#include <Arduino.h>
#include "SPI.h"
#include "Adafruit_GFX.h"
#include "Adafruit_ILI9341.h"

#define TFT_DC 9
#define TFT_CS 10
#define TFT_RST 8
#define TFT_MISO 12
#define TFT_MOSI 11
#define TFT_CLK 13

Adafruit_ILI9341 tft = Adafruit_ILI9341(
TFT_CS, 
TFT_DC, 
TFT_MOSI, 
TFT_CLK, 
TFT_RST, 
TFT_MISO);

#include <Fonts/FreeSerif24pt7b.h>

int Variable1;  

void setup(){

tft.begin();
tft.fillScreen(0x0000);
tft.setTextWrap(false);

tft.setCursor(0, 0);
tft.setTextColor(0xFFFF);
tft.setTextSize(4);
tft.println("Hello");

tft.setFont(&FreeSerif24pt7b);
tft.setTextSize(0);

tft.setCursor(0, 80);
tft.setTextColor(0xF800);
tft.println("World!");

tft.setFont();

tft.drawRect(0, 110, 110, 60, 0x07FF);
tft.drawRoundRect(129, 110, 110, 60, 10, 0x07FF);
tft.drawTriangle(100,240,    130,190,    160,240, 0xFFE0);
tft.fillTriangle(179,240,    209,190,    239,240, 0x07FF);
tft.drawLine(0, 250, 239, 250, 0x07FF);
tft.drawCircle(30, 289, 30, 0x07E0);
tft.fillCircle(110, 289, 30, 0x001F);
tft.fillRoundRect(160, 259, 80, 60, 10, 0xF81B);

}

void loop(){

Variable1++;
if(Variable1 > 150)
{
Variable1 = 0;
}

char string[10];

dtostrf(Variable1, 3, 0, string);

tft.setCursor(21, 125);
tft.setTextColor(0xFFE0, 0x0000);
tft.println(Variable1);

if(Variable1 < 10)
{
tft.fillRect(44, 124, 24, 34, 0x0000);
}
if(Variable1 < 100)
{

tft.fillRect(69, 124, 24, 34, 0x0000);
}

tft.setCursor(150, 125);
tft.setTextColor(0x07E0, 0x0000);
tft.setTextSize(4);
tft.println(string);

tft.fillRect(0, 198, 75, 34, 0x0000);

tft.setFont(&FreeSerif24pt7b);
tft.setTextSize(0);


tft.setCursor(0, 230);
tft.setTextColor(0xF81F);
tft.println(Variable1);


tft.setFont();
}
\end{lstlisting}

\par \noindent
En el código 3.2 todas las funciones hacen referencia a la instancia de la clase "Adafruit\_ILI9341". Con ella se puede pintar pixel por pixel la pantalla utilizando esta clase; sin embargo, ya hay funciones para realizar figuras geométricas como: "drawLine", "drawCircle", "drawTriangle" y "drawRect". Las funciones principales son la de "fillscreen" la cual rellena la pantalla de un solo color y "println" el cual permite imprimir en la pantalla LCD como si fuese una terminal. En el ejemplo para seleccionar los colores del texto se utilizaron números hexadecimales; pero, la librería cuenta con constantes para los colores más comunes.

\par \noindent
Los componentes como el sensor de temperatura DS18B20 y la pantalla LCD ILI9341, son suficiente para realizar un termómetro. El valor agregado del proyecto es la capacidad de poder comunicarse prototipos entre si de manera simultánea, con el fin que uno de ellos sea el que envié la información de las mediciones de temperatura de todos los equipos conectados a la aplicación en Android. Esta comunicación debe ser inalámbrica y el módulo de transmisión de radiofrecuencia es el encargado de dicha tarea.

\subsubsection{Arduino y Modulo nRF24L01+}
\par 
Durante el desarrollo del proyecto se llegó a la siguiente pregunta ¿Cómo enviar de manera inalámbrica los datos capturados de temperatura de cada uno de los prototipos a mi teléfono? Llegamos a 3 opciones: bluetooth, wi-fi y radiofrecuencia.

\begin{enumerate}
	\item Bluetooth: Rápidamente se descartó utilizar Bluetooth, este estándar de transmisión de información inalámbrica requiere en la mayoría de sus versiones una comunicación exclusivamente de dos dispositivos. Un dispositivo actuando como maestro y el otro como esclavo. Descartando automáticamente la idea es conectar múltiples modelos con un teléfono. 
	
	\item Wi-fi: Los teléfonos tienen antenas de Wi-Fi incorporadas y se puede agregar módulos como el ESP8266, que en realidad es un microcontrolador con capacidades inalámbricas. Sin embargo, estos módulos tienen un consumo moderado a alto de energía, el cual una placa Arduino no puede satisfacer de manera consistente y disminuiría el tiempo de operación del prototipo.
	
	
	\item RadioFrecuencia: Es muy parecido a utilizar un módulo Wi-Fi, es más, se encuentran en la misma banda de 2.4 GHz. La ventaja de utilizar esta tecnología es que su consumo de energía es mínimo, por lo que puede ser conectado a un Arduino sin problemas. Otra y quizás la más importante es que los módulos nRF24L01+ cuentan con una característica llamada "MultiCeiver", esta característica permite a un solo modulo actuando como receptor comunicarse con hasta 6 otros módulos actuando como transmisión de manera paralela.  La desventaja es que la mayoría de los smartphones no cuentan con un transceptor compatible con radio frecuencia. Teniendo en cuenta esta limitante se designó utilizar esta tecnología para la comunicación entre los prototipos solamente. 
\end{enumerate} 

\par \noindent
Todos los arquetipos contarían con un chip de radio frecuencia nRF24L01+; pero solo uno sería el encargado de enviar toda la información a el teléfono. 

\par \noindent
El módulo nRF24L01+ requirió de la alimentación del pin de salida 3.3V de la placa Arduino. Adicional se necesitó dos pines digitales para que el Arduino asigne si el módulo funcionara como transmisión o recepción. Por último, este elemento utilizaba el mismo bus que la pantalla LCD ILI9341, la interfaz de bus que se menciona es SPI y por defecto se encuentra en los pines 13, 11 y 12 de nuestro Arduino. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{pruebas4.png}
	\caption{Ejemplo de cómo conectar el módulo nRF24L01+ con un Arduino nano.}
\end{figure}

\par \noindent
Para programar este módulo con Arduino fue necesario el uso de dos librerías: RF24\cite{rf24} y el SPI este último es una de las librerías por defecto que trae Arduino. Dentro de las librerías se encontró un código ejemplo llamado "GettingStarted.ino", es un ejemplo básico de cómo enviar información de un módulo a otro.

\begin{lstlisting}[language=C++, caption={Codigo Ejemplo para módulo nRF24L01+}, captionpos=b]
#include <Arduino.h>

#include <DigitalIO.h>
#include <SPI.h>
#include "RF24.h"

bool radioNumber = 1;

RF24 radio(4,5);

byte addresses[][6] = {"1Node","2Node"};

bool role = 0;

void setup() {
	Serial.begin(115200);
	Serial.println(F("RF24/examples/GettingStarted"));
	Serial.println(
	F("*** PRESS 'T' to begin transmitting to 
	the other node"));
	
	radio.begin();
	radio.setPALevel(RF24_PA_MAX);
	
	if(radioNumber){
		radio.openWritingPipe(addresses[1]);
		radio.openReadingPipe(1,addresses[0]);
	}else{
		radio.openWritingPipe(addresses[0]);
		radio.openReadingPipe(1,addresses[1]);
	}
	
	radio.startListening();
}

void loop() {

	if (role == 1)  {
	
		radio.stopListening();                                    
		
		
		Serial.println(F("Now sending"));
		
		unsigned long start_time = micros();                      
		if (!radio.write( &start_time, sizeof(unsigned long))){
		Serial.println(F("failed"));
		}
		
		radio.startListening();                                   
		
		unsigned long started_waiting_at = micros();              
		boolean timeout = false;                                  
		
		while ( ! radio.available() ){                            
			if (micros() - started_waiting_at > 200000 ){           
				timeout = true;
				break;
			}
		}
		
		if ( timeout ){                                           
			Serial.println(F("Failed, response timed out."));
		}else{
			unsigned long got_time;                               
			radio.read( &got_time, sizeof(unsigned long) );
			unsigned long end_time = micros();
			
			Serial.print(F("Sent "));
			Serial.print(start_time);
			Serial.print(F(", Got response "));
			Serial.print(got_time);
			Serial.print(F(", Round-trip delay "));
			Serial.print(end_time-start_time);
			Serial.println(F(" microseconds"));
		}
		
		delay(1000);
	}
	
	if ( role == 0 ){
		unsigned long got_time;
		
		if( radio.available()){
		
			while (radio.available()){                                  
				radio.read( &got_time, sizeof(unsigned long) );            
			}
			
			radio.stopListening();                                       
			radio.write( &got_time, sizeof(unsigned long) );             
			radio.startListening();                                      
			Serial.print(F("Sent response "));
			Serial.println(got_time);
		}
	}
		
		if ( Serial.available() ){
		char c = toupper(Serial.read());
		if ( c == 'T' && role == 0 ){
		Serial.println(
		F("*** CHANGING TO TRANSMIT ROLE -- 
		PRESS 'R' TO SWITCH BACK"));
		role = 1;                 
		
		}else
		if ( c == 'R' && role == 1 ){
		Serial.println(F("*** CHANGING TO RECEIVE ROLE -- 
		PRESS 'T' TO SWITCH BACK"));
		role = 0;                
		radio.startListening();
		}
	}

} 
	
\end{lstlisting}

\par \noindent
El código 4.3 permite controlar el módulo nRF24L01+ a través del puerto serial de una computadora. En el código se define el radioNumber, un módulo debe ser 0 y el otro 1, una instancia de la clase RF24 cuyos argumentos son los dos pines digitales del Arduino. Un arreglo de tipo byte que básicamente es la dirección que se le asigna a cada módulo y una variable de rol. 

\par \noindent
Al iniciar el programa se abre el puerto serial con 115200 baudios, esto permite a el Arduino a enviar más caracteres por el puerto serial a que si usáramos 9600. 

Se inicia la instancia radio y utilizamos la función "setPALevel" donde se inidica el amplificador de poder del módulo, se utiliza como argumento "RF24\_PA\_MAX" el cual es el valor más alto que acepta el módulo. Seguido de una sentencia if, donde dependiendo del Arduino que se esté usando se abre una "tubería de comunicación" con el otro Arduino a través del módulo, una "tubería" se usa para enviar información y otro para recibir.

\par \noindent
La función loop cuenta de dos partes. Una son las sentencias que indican el rol del Arduino, al inicio ambos Arduinos inician con el rol 0. Si un Arduino tiene en la variable "role" el valor 0, se encuentra en el modo de receptor donde espera un mensaje del otro módulo para enviar una respuesta. En caso contrario y la variable "role" tiene el valor 1, entonces el módulo envía un mensaje al otro módulo y espera la respuesta del mensaje enviado. Esto permite una comunicación bilateral y da más control al Arduino de cómo manejar la información.

\par \noindent
En la segunda parte el Arduino está a la espera de recibir a través del puerto serial, terminal de una computadora, los valores 'T' o 'R'. En caso tal que el usuario escriba 't' o 'T', el Arduino le envía un mensaje al usuario que ha cambiado a modo de transmisión o sea el "role" ahora tiene un valor de 1. Si el usuario escribe 'r' o 'R' entonces nuevamente se envía un mensaje para notificar al usuario y se asigna el valor de "role" a 0. En caso de que el usuario ingrese cualquier otra cosa no pasa nada. La función "loop" se ejecutará una y otra vez, mientras que el Arduino tenga una fuente de poder.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{pruebas5.png}
	\caption{Resultado del código 4.3, dos Arduino comunicándose de manera bilateral utilizando los módulos nRF24L01+.}
\end{figure}

\par \noindent
El módulo nRF24L01+ brinda gran valor para al proyecto por su poco precio; sin embargo, la característica que falta es enviar la información de todos los sensores a nuestro teléfono. Aquí es donde se necesita el módulo bluetooth HC-05.  

\subsubsection{Módulo Bluetooth HC-05}
\par
El módulo bluetooth HC-05 es un clásico en los circuitos de Arduino. Hoy en día todavía se sigue utilizando ya que las versiones de bluetooth son retro compatibles. El HC-05 utiliza la versión de bluetooth 2.0 y hay vasta documentación del módulo en cuestión en la internet. Hay que tomar en cuenta que para trabajar con este módulo hay dos cosas: la pieza necesita una alimentación entre 3.6 a 6 V para funcionar y sus pines de comunicación RXD y TXD lastimosamente no toleran una lógica de 5V; por lo que, hay que aplicar un divisor de voltaje con resistencias. Se utilizó resistencias de 100K ohmios y 200K ohmios para convertir los 5V del Arduino a 3.3V, esto es solo necesario para transmitir del Arduino al HC-05. Para trasmitir del modulo al Arduino no es necesario de convertir de 3.3V a 5V. La conexión del HC-05 con el Arduino sería así:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.65\linewidth]{pruebas8.png}
	\caption{Conexión de Arduino y HC-05}
\end{figure} 

\par \noindent
Se utilizó los pines A4 y A5, estos pueden ser pines digitales también. Adicional un capacitor de 10 uF para brindar una fuente de poder estable.

\par \noindent
Ahora para programar el Arduino para comunicarse con el módulo se utilizó la librería "SoftwareSerial", es una de las librerías por defecto de Arduino, ella permitió utilizar pines digitales como puertos seriales adicionales y comunicar la placa Arduino con el HC-05. El código desarrollado es el siguiente.


\begin{lstlisting}[language=C++, caption={Codigo Ejemplo para módulo HC-05}, captionpos=b]
#include <Arduino.h>
#include <SoftwareSerial.h>
SoftwareSerial BTserial(18, 19); // RX | TX

String json ="{\r\n\"S1\":\"24.56\",
\r\n\"S2\":\"28.10\"\r\n}\r\n";

void setup() {
Serial.begin(9600);
BTserial.begin(9600);  
}

void loop() {
BTserial.println(json); 
Serial.println("Sent.."); 
delay(1000); 
}
\end{lstlisting} 

\par \noindent
En el código ejemplo 3.4 se crea una instancia de la clase SoftwareSerial. Esta clase actúa más como una interfaz y crea una comunicación serial en los pines seleccionados. Siendo el primer parámetro el pin de recepción y el segundo parámetro el pin de transmisión. Se creó una variable tipo "string" el cual simula un texto en formato JSON. En la función "setup" se inicia la comunicación con el puerto serial por defecto del Arduino "Serial" a través de los pines 18 y 19 por la instancia "BTSerial". En la función "loop" se imprime la variable JSON utilizando "BTSerial", donde el HC-05 imprime el valor de la variable JSON. Se imprime por el puerto serial por defecto solamente para validar que el Arduino está funcionando y por último se ejecuta la función "delay", detiene la ejecución del código por el tiempo que se encuentra en el parámetro de la función, la unidad de la función "delay" es milisegundos. 

\par \noindent
Para validar que la información se está enviando por bluetooth. Se utilizó teléfono de desarrollo, el teléfono utilizado fue el Samsung Galaxy S5. Se descarga la aplicación "Bluetooth Terminal"\cite{btterminal} del Play Store de Android. Esta aplicación es una aplicación de terminal y puede realizar transacciones entre el teléfono y el dispositivo bluetooth\cite{btterminal}, en este caso el HC-05.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{pruebas7.png}
	\caption{Resultado del código ejemplo 4.4, utilizando la aplicación "Bluetooth Terminal" en Android.}
\end{figure}

\par \noindent
Una vez validado como programar, conectar y manipular correctamente los componentes necesarios para la elaboración del prototipo. Es momento de integrarlos para el desarrollo de un firmware (código) para el manejo de todos los componentes de manera simultánea por un Arduino. Por lo que es momento de realizar un circuito tentativo o esquematico del arquetipo.

\subsubsection{Circuito Tentativo}
\par 
El circuito tentativo del dispositivo es una combinación de todos los componentes seleccionados en un solo circuito. El elemento principal es el Arduino Nano y es donde subiremos el firmware. El Esquemático del prototipo es el siguiente:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.65\linewidth]{circuitotentativo2.png}
	\caption{Versión 1.1 del Circuito del Prototipo de Medición de Temperatura.}
\end{figure}
